'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var EventEmitter = _interopDefault(require('events'));
var sqlite3 = _interopDefault(require('sqlite3'));
var genericPool = _interopDefault(require('generic-pool'));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/**
 * Pooled SQLite client library for Node.js
 * Based on the node-sqlite library
 *
 * Copyright © 2017 Raymond Neilson. All rights reserved.
 *
 * Original work copyright © 2016 Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

function prepareParams(args) {
  var requireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var callback = void 0;
  if (requireCallback) {
    if (args.length < 1) {
      throw new Error('Callback argument is required');
    }
    callback = args.pop();
  }
  var params = args.length === 1 ? args[0] : args;
  return callback ? [params, callback] : params;
}

function isThenable(obj) {
  return obj !== undefined && obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && 'then' in obj && typeof obj.then === 'function';
}

function asyncRunner() {
  var Promise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : global.Promise;

  return function runAsync(fn) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var gen = fn.apply(this, args);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        var info = void 0;
        var value = void 0;

        try {
          info = gen[key](arg);
          value = info.value;
        } catch (error) {
          return reject(error);
        }

        if (info.done) {
          return resolve(value);
        }
        return Promise.resolve(value).then(function (val) {
          step('next', val);
        }, function (err) {
          step('throw', err);
        });
      }

      return step('next');
    });
  };
}

/**
 * Pooled SQLite client library for Node.js
 * Based on the node-sqlite library
 *
 * Copyright © 2017 Raymond Neilson. All rights reserved.
 *
 * Original work copyright © 2016 Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

var Statement = function () {
  function Statement(stmt, Promise) {
    classCallCheck(this, Statement);

    this.stmt = stmt;
    this.Promise = Promise;
  }

  createClass(Statement, [{
    key: 'bind',
    value: function bind() {
      var _this = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var params = prepareParams(args);

      return new this.Promise(function (resolve, reject) {
        _this.stmt.bind(params, function (err) {
          if (err) {
            reject(err);
          } else {
            resolve(_this);
          }
        });
      });
    }
  }, {
    key: 'reset',
    value: function reset() {
      var _this2 = this;

      return new this.Promise(function (resolve) {
        _this2.stmt.reset(function () {
          resolve(_this2);
        });
      });
    }
  }, {
    key: 'finalize',
    value: function finalize() {
      var _this3 = this;

      return new this.Promise(function (resolve, reject) {
        _this3.stmt.finalize(function (err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
  }, {
    key: 'run',
    value: function run() {
      var _this4 = this;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var params = prepareParams(args);

      return new this.Promise(function (resolve, reject) {
        _this4.stmt.run(params, function (err) {
          if (err) {
            reject(err);
          } else {
            resolve(_this4);
          }
        });
      });
    }
  }, {
    key: 'get',
    value: function get() {
      var _this5 = this;

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var params = prepareParams(args);

      return new this.Promise(function (resolve, reject) {
        _this5.stmt.get(params, function (err, row) {
          if (err) {
            reject(err);
          } else {
            resolve(row);
          }
        });
      });
    }
  }, {
    key: 'all',
    value: function all() {
      var _this6 = this;

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var params = prepareParams(args);

      return new this.Promise(function (resolve, reject) {
        _this6.stmt.all(params, function (err, rows) {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
    }
  }, {
    key: 'each',
    value: function each() {
      var _this7 = this;

      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var _prepareParams = prepareParams(args, true),
          _prepareParams2 = slicedToArray(_prepareParams, 2),
          params = _prepareParams2[0],
          callback = _prepareParams2[1];

      return new this.Promise(function (resolve, reject) {
        var error = null;

        var cb = function cb(err, row) {
          if (error !== null) {
            return;
          }
          try {
            callback(row);
          } catch (e) {
            error = e;
          }
        };

        var done = function done(err) {
          var rowsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          if (err) {
            reject(err);
          } else if (error) {
            reject(error);
          } else {
            resolve(rowsCount);
          }
        };

        _this7.stmt.each(params, cb, done);
      });
    }
  }, {
    key: 'sql',
    get: function get() {
      return this.stmt.sql;
    }
  }, {
    key: 'lastID',
    get: function get() {
      return this.stmt.lastID;
    }
  }, {
    key: 'changes',
    get: function get() {
      return this.stmt.changes;
    }
  }]);
  return Statement;
}();

/**
 * Pooled SQLite client library for Node.js
 * Based on the node-sqlite library
 *
 * Copyright © 2017 Raymond Neilson. All rights reserved.
 *
 * Original work copyright © 2016 Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

var Database = function () {

  /**
   * Initializes a new instance of the database client.
   * @param driver An instance of SQLite3 driver library.
   * @param promiseLibrary ES6 Promise library to use.
     */
  function Database(driver, _ref) {
    var Promise = _ref.Promise,
        trxImmediate = _ref.trxImmediate,
        _ref$trxParent = _ref.trxParent,
        trxParent = _ref$trxParent === undefined ? null : _ref$trxParent;
    classCallCheck(this, Database);

    this.driver = driver;
    this.Promise = Promise;
    this._async = asyncRunner(Promise);
    this._immediate = trxImmediate;
    this._parent = trxParent;
    this._trx = null;
  }

  createClass(Database, [{
    key: 'run',
    value: function run(sql) {
      var _this = this;

      this._trxCheck();
      var Promise = this.Promise;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var params = prepareParams(args);

      return new Promise(function (resolve, reject) {
        _this.driver.run(sql, params, function runExecResult(err) {
          if (err) {
            reject(err);
          } else {
            // Per https://github.com/mapbox/node-sqlite3/wiki/API#databaserunsql-param--callback
            // when run() succeeds, the `this' object is a driver statement object. Wrap it as a
            // Statement.
            resolve(new Statement(this, Promise));
          }
        });
      });
    }
  }, {
    key: 'get',
    value: function get(sql) {
      var _this2 = this;

      this._trxCheck();

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var params = prepareParams(args);

      return new this.Promise(function (resolve, reject) {
        _this2.driver.get(sql, params, function (err, row) {
          if (err) {
            reject(err);
          } else {
            resolve(row);
          }
        });
      });
    }
  }, {
    key: 'all',
    value: function all(sql) {
      var _this3 = this;

      this._trxCheck();

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      var params = prepareParams(args);

      return new this.Promise(function (resolve, reject) {
        _this3.driver.all(sql, params, function (err, rows) {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
    }

    /**
     * Runs all the SQL queries in the supplied string. No result rows are retrieved.
     */

  }, {
    key: 'exec',
    value: function exec(sql) {
      var _this4 = this;

      this._trxCheck();

      return new this.Promise(function (resolve, reject) {
        _this4.driver.exec(sql, function (err) {
          if (err) {
            reject(err);
          } else {
            resolve(_this4);
          }
        });
      });
    }
  }, {
    key: 'each',
    value: function each(sql) {
      var _this5 = this;

      this._trxCheck();

      for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      var _prepareParams = prepareParams(args, true),
          _prepareParams2 = slicedToArray(_prepareParams, 2),
          params = _prepareParams2[0],
          callback = _prepareParams2[1];

      return new this.Promise(function (resolve, reject) {
        var error = null;

        var cb = function cb(err, row) {
          if (error !== null) {
            return;
          }
          try {
            callback(row);
          } catch (e) {
            error = e;
          }
        };

        var done = function done(err) {
          var rowsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          if (err) {
            reject(err);
          } else if (error) {
            reject(error);
          } else {
            resolve(rowsCount);
          }
        };

        _this5.driver.each(sql, params, cb, done);
      });
    }
  }, {
    key: 'prepare',
    value: function prepare(sql) {
      var _this6 = this;

      this._trxCheck();

      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      var params = prepareParams(args);

      return new this.Promise(function (resolve, reject) {
        var stmt = _this6.driver.prepare(sql, params, function (err) {
          if (err) {
            reject(err);
          } else {
            resolve(new Statement(stmt, _this6.Promise));
          }
        });
      });
    }
  }, {
    key: 'wait',
    value: function wait() {
      var _this7 = this;

      this._trxCheck();

      return new this.Promise(function (resolve, reject) {
        _this7.driver.wait(function (err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
  }, {
    key: 'transaction',
    value: function transaction(fn) {
      var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._immediate;

      return this._trxWrap(fn, immediate);
    }
  }, {
    key: 'transactionAsync',
    value: function transactionAsync(gen) {
      var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._immediate;

      return this._trxWrap(gen, immediate, true);
    }
  }, {
    key: '_trxCheck',
    value: function _trxCheck() {
      var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this._trx !== null) {
        throw new Error('A transaction is currently active for this connection');
      } else if (parent && this._parent !== null) {
        throw new Error('Managed savepoints are not supported at this time');
      }
    }
  }, {
    key: '_trxWrap',
    value: function _trxWrap(fn, immediate) {
      var isAsync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this._trxCheck(true);

      return this._async(regeneratorRuntime.mark(function _trxWrapAsync() {
        var trx, result;
        return regeneratorRuntime.wrap(function _trxWrapAsync$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Create child Database object for transaction
                trx = new Database(this.driver, {
                  Promise: this.Promise,
                  trxImmediate: this._immediate,
                  trxParent: this
                });

                // Begin transaction

                _context.next = 3;
                return immediate ? trx.exec('BEGIN IMMEDIATE') : trx.exec('BEGIN');

              case 3:
                this._trx = trx;

                result = void 0;
                _context.prev = 5;
                _context.next = 8;
                return isAsync ? this._async(fn, trx) : fn.call(this, trx);

              case 8:
                result = _context.sent;
                _context.next = 11;
                return trx.exec('COMMIT');

              case 11:
                _context.next = 18;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context['catch'](5);
                _context.next = 17;
                return trx.exec('ROLLBACK');

              case 17:
                throw _context.t0;

              case 18:
                _context.prev = 18;

                this._trx = null;
                return _context.finish(18);

              case 21:
                return _context.abrupt('return', result);

              case 22:
              case 'end':
                return _context.stop();
            }
          }
        }, _trxWrapAsync, this, [[5, 13, 18, 21]]);
      }));
    }
  }]);
  return Database;
}();

/**
 * Pooled SQLite client library for Node.js
 * Based on the node-sqlite library
 *
 * Copyright © 2017 Raymond Neilson. All rights reserved.
 *
 * Original work copyright © 2016 Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

// Default options
var defaults$$1 = {
  // sqlite defaults
  mode: null,
  verbose: false,
  busyTimeout: 1000,
  foreignKeys: true,
  walMode: true,
  loadExtensions: [],

  // pool defaults
  min: 1,
  max: 4,
  acquireTimeout: 1000,

  // internal defaults
  trxImmediate: true,
  delayRelease: true,

  // general defaults
  Promise: global.Promise
};

var Sqlite = function (_EventEmitter) {
  inherits(Sqlite, _EventEmitter);

  function Sqlite() {
    var filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ':memory:';
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, Sqlite);

    // Extract options
    var _this = possibleConstructorReturn(this, (Sqlite.__proto__ || Object.getPrototypeOf(Sqlite)).call(this));

    var _Object$assign = Object.assign({}, defaults$$1, options),
        mode = _Object$assign.mode,
        verbose = _Object$assign.verbose,
        busyTimeout = _Object$assign.busyTimeout,
        foreignKeys = _Object$assign.foreignKeys,
        walMode = _Object$assign.walMode,
        loadExtensions = _Object$assign.loadExtensions,
        min = _Object$assign.min,
        max = _Object$assign.max,
        trxImmediate = _Object$assign.trxImmediate,
        delayRelease = _Object$assign.delayRelease,
        acquireTimeout = _Object$assign.acquireTimeout,
        Promise = _Object$assign.Promise;

    // Re-consolidate options


    _this._pool_opts = { min: min, max: max, Promise: Promise, acquireTimeoutMillis: acquireTimeout };
    _this._sqlite_opts = { mode: mode, verbose: verbose, busyTimeout: busyTimeout, foreignKeys: foreignKeys, walMode: walMode };
    _this._sqlite_file = filename;
    _this._sqlite_extn = loadExtensions;
    _this._immediate = trxImmediate;
    _this.delayRelease = delayRelease;
    _this.Promise = Promise;

    // Async runner
    _this._async = asyncRunner(Promise);

    // Special case min/max for anonymous or in-memory database
    if (filename === '' || filename === ':memory:') {
      _this._pool_opts.min = 1;
      _this._pool_opts.max = 1;
    }

    // Factory functions for generic-pool
    _this._pool_factory = {
      create: function create() {
        return _this._create();
      },

      destroy: function destroy(connection) {
        return _this._destroy(connection);
      }
    };

    // Create pool
    _this._pool = genericPool.createPool(_this._pool_factory, _this._pool_opts);

    // Re-emit pool errors
    _this._pool.on('factoryCreateError', function (err) {
      return _this.emit('error', err);
    });
    _this._pool.on('factoryDestroyError', function (err) {
      return _this.emit('error', err);
    });
    return _this;
  }

  createClass(Sqlite, [{
    key: '_create',
    value: function _create() {
      return this._async(regeneratorRuntime.mark(function _createAsync() {
        var _this2 = this;

        var Promise, trxImmediate, options, filename, connection, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;

        return regeneratorRuntime.wrap(function _createAsync$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                Promise = this.Promise;
                trxImmediate = this._immediate;
                options = this._sqlite_opts;
                filename = this._sqlite_file;

                // Create database connection, wait until open complete

                _context2.next = 6;
                return new Promise(function (resolve, reject) {
                  var driver = void 0;
                  var callback = function callback(err) {
                    if (err) {
                      return reject(err);
                    }
                    return resolve(new Database(driver, { Promise: Promise, trxImmediate: trxImmediate }));
                  };

                  if (options.mode !== null) {
                    driver = new sqlite3.Database(filename, options.mode, callback);
                  } else {
                    driver = new sqlite3.Database(filename, callback);
                  }

                  // Add event re-emitters
                  driver.on('error', function (err) {
                    return _this2.emit('error', err);
                  });
                  driver.once('open', function () {
                    return _this2.emit('open', filename, driver);
                  });
                  driver.once('close', function () {
                    return _this2.emit('close', filename, driver);
                  });

                  // Can't reset this
                  if (options.verbose) {
                    driver.verbose();
                    driver.on('trace', function () {
                      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                      }

                      return _this2.emit.apply(_this2, ['trace'].concat(args));
                    });
                    driver.on('profile', function () {
                      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        args[_key2] = arguments[_key2];
                      }

                      return _this2.emit.apply(_this2, ['profile'].concat(args));
                    });
                  }

                  // Busy timeout default hardcoded to 1000ms, so
                  // only configure if a different value given
                  if (options.busyTimeout !== 1000) {
                    driver.configure('busyTimeout', options.busyTimeout);
                  }
                });

              case 6:
                connection = _context2.sent;


                // Await each for consistency
                // Load extensions
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context2.prev = 10;
                _loop = regeneratorRuntime.mark(function _loop() {
                  var extension, extensionPath;
                  return regeneratorRuntime.wrap(function _loop$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          extension = _step.value;
                          extensionPath = path.resolve(extension);
                          _context.next = 4;
                          return new Promise(function (resolve, reject) {
                            connection.driver.loadExtension(extensionPath, function (err) {
                              if (err) {
                                return reject(err);
                              }
                              return resolve();
                            });
                          });

                        case 4:
                        case 'end':
                          return _context.stop();
                      }
                    }
                  }, _loop, _this2);
                });
                _iterator = this._sqlite_extn[Symbol.iterator]();

              case 13:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context2.next = 18;
                  break;
                }

                return _context2.delegateYield(_loop(), 't0', 15);

              case 15:
                _iteratorNormalCompletion = true;
                _context2.next = 13;
                break;

              case 18:
                _context2.next = 24;
                break;

              case 20:
                _context2.prev = 20;
                _context2.t1 = _context2['catch'](10);
                _didIteratorError = true;
                _iteratorError = _context2.t1;

              case 24:
                _context2.prev = 24;
                _context2.prev = 25;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 27:
                _context2.prev = 27;

                if (!_didIteratorError) {
                  _context2.next = 30;
                  break;
                }

                throw _iteratorError;

              case 30:
                return _context2.finish(27);

              case 31:
                return _context2.finish(24);

              case 32:
                if (!options.foreignKeys) {
                  _context2.next = 35;
                  break;
                }

                _context2.next = 35;
                return connection.exec('PRAGMA foreign_keys = ON;');

              case 35:
                if (!options.walMode) {
                  _context2.next = 38;
                  break;
                }

                _context2.next = 38;
                return connection.exec('PRAGMA journal_mode = WAL;');

              case 38:
                return _context2.abrupt('return', connection);

              case 39:
              case 'end':
                return _context2.stop();
            }
          }
        }, _createAsync, this, [[10, 20, 24, 32], [25,, 27, 31]]);
      }));
    }
  }, {
    key: '_destroy',
    value: function _destroy(connection) {
      return new this.Promise(function (resolve, reject) {
        connection.driver.close(function (err) {
          if (err) {
            return reject(err);
          }
          return resolve();
        });
      });
    }
  }, {
    key: '_release',
    value: function _release(connection) {
      var _this3 = this;

      if (this.delayRelease) {
        return setImmediate(function () {
          return _this3._pool.release(connection);
        });
      }
      return this._pool.release(connection);
    }
  }, {
    key: '_acquireRelease',
    value: function _acquireRelease(fn) {
      var isAsync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      return this._async(regeneratorRuntime.mark(function _acquireReleaseAsync() {
        var connection, result;
        return regeneratorRuntime.wrap(function _acquireReleaseAsync$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._pool.acquire();

              case 2:
                connection = _context3.sent;
                result = void 0;
                _context3.prev = 4;

                if (!isAsync) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 8;
                return this._async(fn, connection);

              case 8:
                result = _context3.sent;
                _context3.next = 14;
                break;

              case 11:
                _context3.next = 13;
                return fn.call(this, connection);

              case 13:
                result = _context3.sent;

              case 14:
                _context3.prev = 14;

                this._release(connection);
                return _context3.finish(14);

              case 17:
                return _context3.abrupt('return', result);

              case 18:
              case 'end':
                return _context3.stop();
            }
          }
        }, _acquireReleaseAsync, this, [[4,, 14, 17]]);
      }));
    }
  }, {
    key: 'close',
    value: function close() {
      return this._async(regeneratorRuntime.mark(function _close() {
        var _this4 = this;

        var to_close, drained, closing;
        return regeneratorRuntime.wrap(function _close$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                to_close = [];
                // Queue up enough acquire() calls for all pooled connections

                while (to_close.length < this._pool.size) {
                  to_close.push(this._pool.acquire().catch(function () {}));
                }
                // Now set pool to draining to block further acquisitions
                drained = this._pool.drain();
                // Wait until acquired

                _context4.next = 5;
                return Promise.all(to_close);

              case 5:
                _context4.t0 = function (c) {
                  return !!c;
                };

                closing = _context4.sent.filter(_context4.t0);

                // Close and destroy all but last connection
                closing.splice(1).forEach(function (conn) {
                  return _this4._pool.destroy(conn);
                });
                // Wait until only last connection open

              case 8:
                if (!(this._pool.size > 1)) {
                  _context4.next = 13;
                  break;
                }

                _context4.next = 11;
                return new Promise(function (resolve) {
                  return setImmediate(resolve);
                });

              case 11:
                _context4.next = 8;
                break;

              case 13:
                // Clear last connection, and let pool finish draining
                closing.forEach(function (conn) {
                  return _this4._pool.destroy(conn);
                });
                _context4.next = 16;
                return drained;

              case 16:
                _context4.next = 18;
                return this._pool.clear();

              case 18:
              case 'end':
                return _context4.stop();
            }
          }
        }, _close, this);
      }));
    }
  }, {
    key: 'exec',
    value: function exec() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this._acquireRelease(function (conn) {
        return conn.exec.apply(conn, args);
      }).then(function () {});
    }
  }, {
    key: 'run',
    value: function run() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this._acquireRelease(function (conn) {
        return conn.run.apply(conn, args);
      });
    }
  }, {
    key: 'get',
    value: function get() {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return this._acquireRelease(function (conn) {
        return conn.get.apply(conn, args);
      });
    }
  }, {
    key: 'all',
    value: function all() {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return this._acquireRelease(function (conn) {
        return conn.all.apply(conn, args);
      });
    }
  }, {
    key: 'each',
    value: function each() {
      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return this._acquireRelease(function (conn) {
        return conn.each.apply(conn, args);
      });
    }
  }, {
    key: 'use',
    value: function use(fn) {
      var _this5 = this;

      return this._acquireRelease(function (conn) {
        // Pass connection to function
        var result = fn.call(_this5, conn);

        // If function didn't return a thenable, wait
        return isThenable(result) ? result : conn.wait().then(function () {
          return result;
        });
      });
    }
  }, {
    key: 'useAsync',
    value: function useAsync(gen) {
      return this._acquireRelease(gen, true);
    }
  }, {
    key: 'transaction',
    value: function transaction(fn) {
      var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._immediate;

      return this._acquireRelease(function (conn) {
        return conn.transaction(fn, immediate);
      });
    }
  }, {
    key: 'transactionAsync',
    value: function transactionAsync(gen) {
      var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._immediate;

      return this._acquireRelease(function (conn) {
        return conn.transactionAsync(gen, immediate);
      });
    }

    /**
     * Migrates database schema to the latest version
     */

  }, {
    key: 'migrate',
    value: function migrate() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          force = _ref.force,
          _ref$table = _ref.table,
          table = _ref$table === undefined ? 'migrations' : _ref$table,
          _ref$migrationsPath = _ref.migrationsPath,
          migrationsPath = _ref$migrationsPath === undefined ? './migrations' : _ref$migrationsPath;

      return this._async(regeneratorRuntime.mark(function _migrateAsync() {
        var Promise, location, migrations;
        return regeneratorRuntime.wrap(function _migrateAsync$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                Promise = this.Promise;
                location = path.resolve(migrationsPath);

                // Get the list of migration files, for example:
                //   { id: 1, name: 'initial', filename: '001-initial.sql' }
                //   { id: 2, name: 'feature', fielname: '002-feature.sql' }

                _context10.next = 4;
                return new Promise(function (resolve, reject) {
                  fs.readdir(location, function (err, files) {
                    if (err) {
                      reject(err);
                    } else {
                      resolve(files.map(function (x) {
                        return x.match(/^(\d+).(.*?)\.sql$/);
                      }).filter(function (x) {
                        return x !== null;
                      }).map(function (x) {
                        return { id: Number(x[1]), name: x[2], filename: x[0] };
                      }).sort(function (a, b) {
                        return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;
                      }));
                    }
                  });
                });

              case 4:
                migrations = _context10.sent;

                if (migrations.length) {
                  _context10.next = 7;
                  break;
                }

                throw new Error('No migration files found in \'' + location + '\'.');

              case 7:
                _context10.next = 9;
                return Promise.all(migrations.map(function (migration) {
                  return new Promise(function (resolve, reject) {
                    var filename = path.join(location, migration.filename);
                    fs.readFile(filename, 'utf-8', function (err, data) {
                      if (err) {
                        reject(err);
                      } else {
                        var _data$split = data.split(/^--\s+?down/mi),
                            _data$split2 = slicedToArray(_data$split, 2),
                            up = _data$split2[0],
                            down = _data$split2[1];

                        if (!down) {
                          reject(new Error('The file ' + migration.filename + ' is missing a \'-- Down\' separator.'));
                        } else {
                          // Remove comments and trim whitespaces
                          /* eslint-disable no-param-reassign */
                          migration.up = up.replace(/^--.*?$/gm, '').trim();
                          migration.down = down.replace(/^--.*?$/gm, '').trim();
                          /* eslint-enable no-param-reassign */
                          resolve();
                        }
                      }
                    });
                  });
                }));

              case 9:
                _context10.next = 11;
                return this.useAsync(regeneratorRuntime.mark(function _runMigrationsAsync(conn) {
                  var _this6 = this;

                  var dbMigrations, lastMigration, prev, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _loop2, _iterator2, _step2, _ret2, lastMigrationId, maxMigrationId, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _loop3, _iterator3, _step3;

                  return regeneratorRuntime.wrap(function _runMigrationsAsync$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _context9.next = 2;
                          return conn.run('CREATE TABLE IF NOT EXISTS "' + table + '" (\n    id   INTEGER PRIMARY KEY,\n    name TEXT    NOT NULL,\n    up   TEXT    NOT NULL,\n    down TEXT    NOT NULL\n  )');

                        case 2:
                          _context9.next = 4;
                          return conn.all('SELECT id, name, up, down FROM "' + table + '" ORDER BY id ASC');

                        case 4:
                          dbMigrations = _context9.sent;


                          // Undo migrations that exist only in the database but not in files,
                          // also undo the last migration if the `force` option was set to `last`.
                          lastMigration = migrations[migrations.length - 1];
                          prev = dbMigrations.slice().sort(function (a, b) {
                            return a.id < b.id ? 1 : a.id > b.id ? -1 : 0;
                          });
                          _iteratorNormalCompletion2 = true;
                          _didIteratorError2 = false;
                          _iteratorError2 = undefined;
                          _context9.prev = 10;
                          _loop2 = regeneratorRuntime.mark(function _loop2() {
                            var migration;
                            return regeneratorRuntime.wrap(function _loop2$(_context6) {
                              while (1) {
                                switch (_context6.prev = _context6.next) {
                                  case 0:
                                    migration = _step2.value;

                                    if (!(!migrations.some(function (x) {
                                      return x.id === migration.id;
                                    }) || Number.isInteger(force) && migration.id > force || force === 'last' && migration.id === lastMigration.id)) {
                                      _context6.next = 7;
                                      break;
                                    }

                                    _context6.next = 4;
                                    return conn.transactionAsync(regeneratorRuntime.mark(function _downAsync(trx) {
                                      return regeneratorRuntime.wrap(function _downAsync$(_context5) {
                                        while (1) {
                                          switch (_context5.prev = _context5.next) {
                                            case 0:
                                              _context5.next = 2;
                                              return trx.exec(migration.down);

                                            case 2:
                                              _context5.next = 4;
                                              return trx.run('DELETE FROM "' + table + '" WHERE id = ?', migration.id);

                                            case 4:
                                            case 'end':
                                              return _context5.stop();
                                          }
                                        }
                                      }, _downAsync, this);
                                    }));

                                  case 4:
                                    dbMigrations = dbMigrations.filter(function (x) {
                                      return x.id !== migration.id;
                                    });
                                    _context6.next = 8;
                                    break;

                                  case 7:
                                    return _context6.abrupt('return', 'break');

                                  case 8:
                                  case 'end':
                                    return _context6.stop();
                                }
                              }
                            }, _loop2, _this6);
                          });
                          _iterator2 = prev[Symbol.iterator]();

                        case 13:
                          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                            _context9.next = 21;
                            break;
                          }

                          return _context9.delegateYield(_loop2(), 't0', 15);

                        case 15:
                          _ret2 = _context9.t0;

                          if (!(_ret2 === 'break')) {
                            _context9.next = 18;
                            break;
                          }

                          return _context9.abrupt('break', 21);

                        case 18:
                          _iteratorNormalCompletion2 = true;
                          _context9.next = 13;
                          break;

                        case 21:
                          _context9.next = 27;
                          break;

                        case 23:
                          _context9.prev = 23;
                          _context9.t1 = _context9['catch'](10);
                          _didIteratorError2 = true;
                          _iteratorError2 = _context9.t1;

                        case 27:
                          _context9.prev = 27;
                          _context9.prev = 28;

                          if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                          }

                        case 30:
                          _context9.prev = 30;

                          if (!_didIteratorError2) {
                            _context9.next = 33;
                            break;
                          }

                          throw _iteratorError2;

                        case 33:
                          return _context9.finish(30);

                        case 34:
                          return _context9.finish(27);

                        case 35:

                          // Apply pending migrations
                          lastMigrationId = dbMigrations.length ? dbMigrations[dbMigrations.length - 1].id : 0;
                          maxMigrationId = Number.isInteger(force) ? force : migrations[migrations.length - 1].id;
                          _iteratorNormalCompletion3 = true;
                          _didIteratorError3 = false;
                          _iteratorError3 = undefined;
                          _context9.prev = 40;
                          _loop3 = regeneratorRuntime.mark(function _loop3() {
                            var migration;
                            return regeneratorRuntime.wrap(function _loop3$(_context8) {
                              while (1) {
                                switch (_context8.prev = _context8.next) {
                                  case 0:
                                    migration = _step3.value;

                                    if (!(migration.id > lastMigrationId && migration.id <= maxMigrationId)) {
                                      _context8.next = 4;
                                      break;
                                    }

                                    _context8.next = 4;
                                    return conn.transactionAsync(regeneratorRuntime.mark(function _upAsync(trx) {
                                      return regeneratorRuntime.wrap(function _upAsync$(_context7) {
                                        while (1) {
                                          switch (_context7.prev = _context7.next) {
                                            case 0:
                                              _context7.next = 2;
                                              return trx.exec(migration.up);

                                            case 2:
                                              _context7.next = 4;
                                              return trx.run('INSERT INTO "' + table + '" (id, name, up, down) VALUES (?, ?, ?, ?)', migration.id, migration.name, migration.up, migration.down);

                                            case 4:
                                            case 'end':
                                              return _context7.stop();
                                          }
                                        }
                                      }, _upAsync, this);
                                    }));

                                  case 4:
                                  case 'end':
                                    return _context8.stop();
                                }
                              }
                            }, _loop3, _this6);
                          });
                          _iterator3 = migrations[Symbol.iterator]();

                        case 43:
                          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                            _context9.next = 48;
                            break;
                          }

                          return _context9.delegateYield(_loop3(), 't2', 45);

                        case 45:
                          _iteratorNormalCompletion3 = true;
                          _context9.next = 43;
                          break;

                        case 48:
                          _context9.next = 54;
                          break;

                        case 50:
                          _context9.prev = 50;
                          _context9.t3 = _context9['catch'](40);
                          _didIteratorError3 = true;
                          _iteratorError3 = _context9.t3;

                        case 54:
                          _context9.prev = 54;
                          _context9.prev = 55;

                          if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                          }

                        case 57:
                          _context9.prev = 57;

                          if (!_didIteratorError3) {
                            _context9.next = 60;
                            break;
                          }

                          throw _iteratorError3;

                        case 60:
                          return _context9.finish(57);

                        case 61:
                          return _context9.finish(54);

                        case 62:
                        case 'end':
                          return _context9.stop();
                      }
                    }
                  }, _runMigrationsAsync, this, [[10, 23, 27, 35], [28,, 30, 34], [40, 50, 54, 62], [55,, 57, 61]]);
                }));

              case 11:
                return _context10.abrupt('return', this);

              case 12:
              case 'end':
                return _context10.stop();
            }
          }
        }, _migrateAsync, this);
      }));
    }
  }], [{
    key: 'Database',
    get: function get() {
      return Database;
    }
  }, {
    key: 'Statement',
    get: function get() {
      return Statement;
    }
  }, {
    key: 'OPEN_READONLY',
    get: function get() {
      return sqlite3.OPEN_READONLY;
    }
  }, {
    key: 'OPEN_READWRITE',
    get: function get() {
      return sqlite3.OPEN_READWRITE;
    }
  }, {
    key: 'OPEN_CREATE',
    get: function get() {
      return sqlite3.OPEN_CREATE;
    }
  }, {
    key: 'VERSION',
    get: function get() {
      return sqlite3.VERSION;
    }
  }, {
    key: 'SOURCE_ID',
    get: function get() {
      return sqlite3.SOURCE_ID;
    }
  }, {
    key: 'VERSION_NUMBER',
    get: function get() {
      return sqlite3.VERSION_NUMBER;
    }
  }, {
    key: 'OK',
    get: function get() {
      return sqlite3.OK;
    }
  }, {
    key: 'ERROR',
    get: function get() {
      return sqlite3.ERROR;
    }
  }, {
    key: 'INTERNAL',
    get: function get() {
      return sqlite3.INTERNAL;
    }
  }, {
    key: 'PERM',
    get: function get() {
      return sqlite3.PERM;
    }
  }, {
    key: 'ABORT',
    get: function get() {
      return sqlite3.ABORT;
    }
  }, {
    key: 'BUSY',
    get: function get() {
      return sqlite3.BUSY;
    }
  }, {
    key: 'LOCKED',
    get: function get() {
      return sqlite3.LOCKED;
    }
  }, {
    key: 'NOMEM',
    get: function get() {
      return sqlite3.NOMEM;
    }
  }, {
    key: 'READONLY',
    get: function get() {
      return sqlite3.READONLY;
    }
  }, {
    key: 'INTERRUPT',
    get: function get() {
      return sqlite3.INTERRUPT;
    }
  }, {
    key: 'IOERR',
    get: function get() {
      return sqlite3.IOERR;
    }
  }, {
    key: 'CORRUPT',
    get: function get() {
      return sqlite3.CORRUPT;
    }
  }, {
    key: 'NOTFOUND',
    get: function get() {
      return sqlite3.NOTFOUND;
    }
  }, {
    key: 'FULL',
    get: function get() {
      return sqlite3.FULL;
    }
  }, {
    key: 'CANTOPEN',
    get: function get() {
      return sqlite3.CANTOPEN;
    }
  }, {
    key: 'PROTOCOL',
    get: function get() {
      return sqlite3.PROTOCOL;
    }
  }, {
    key: 'EMPTY',
    get: function get() {
      return sqlite3.EMPTY;
    }
  }, {
    key: 'SCHEMA',
    get: function get() {
      return sqlite3.SCHEMA;
    }
  }, {
    key: 'TOOBIG',
    get: function get() {
      return sqlite3.TOOBIG;
    }
  }, {
    key: 'CONSTRAINT',
    get: function get() {
      return sqlite3.CONSTRAINT;
    }
  }, {
    key: 'MISMATCH',
    get: function get() {
      return sqlite3.MISMATCH;
    }
  }, {
    key: 'MISUSE',
    get: function get() {
      return sqlite3.MISUSE;
    }
  }, {
    key: 'NOLFS',
    get: function get() {
      return sqlite3.NOLFS;
    }
  }, {
    key: 'AUTH',
    get: function get() {
      return sqlite3.AUTH;
    }
  }, {
    key: 'FORMAT',
    get: function get() {
      return sqlite3.FORMAT;
    }
  }, {
    key: 'RANGE',
    get: function get() {
      return sqlite3.RANGE;
    }
  }, {
    key: 'NOTADB',
    get: function get() {
      return sqlite3.NOTADB;
    }
  }]);
  return Sqlite;
}(EventEmitter);

module.exports = Sqlite;
//# sourceMappingURL=legacy.js.map
